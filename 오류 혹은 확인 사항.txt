*강의 따라 가는 중 나온 오류 사항
ERROR in multi ./app/index.js dist/bundle.js
Module not found: Error: Can't resolve 'dist/bundle.js' in 'C:\Users\Youn\Deskto
p\etc\webpack'
 @ multi ./app/index.js dist/bundle.js

 webpack 버전이 4.0 이상으로 올라가면서 기존에 사용하던 아래의 문구를 사용하는 것이 아닌 변경된 것으로 사용해야 한다.

        -> webpack app/index.js dist/bundle.js

        -> webpack app/index.js --output dist/bundle.js --mode development

** install --save 와 --save-dev의 차이
        -> --save는 앱이 구동하기 위해 필요한 모듈 & 라이브러리
        -> --save-dev는 앱 개발시에 필요한 모듈 & 라이브러리 설치(예: test, build tool, live reloading 등)

* webpack entry
        -> 묶을 라이브러리에 대한 시작점
        -> a,b,c라는 라이브러리를 모두 번들링한 bundle.js를 로딩한다.
        -> 1개 또는 2개 이상의 엔트리 포인트를 설정할 수 있다.

* 엔트리 유형
        -> 간단한 entry 설정
           entry : "path/*.js"
        -> 앱 로직용 , 외부 라이브러리 용
           entry : {
                        app: "./app.js",
                        vendor : "./vendor.js"
                }
        -> 페이지당 불러오는 js 설정
           entry : {
                        pageOne : "./src/pageOne/index.js",
                        pageTwo : "./src/pageTwo/index.js",
                        pageThree : "./src/pageThree/index.js",
                }

* Multiple Entry points
        -> 앞에 복수개 엔트리 포인트에 대한 설정 예시
        module.exports = {
                 entry : {
                              app: "./app.js",
                              vendor : "./vendor.js"
                  },
                  output: {
                    filename: '[name].js', // 위에 지정한 엔트리 키의 이름에 맞춰서 결과 산출
                    path: 'build'
                  }
        }
        -> 번들파일은 app.js를 임포트 하면 된다.

* Webpack output
        - 엔트리에서 설정하고 묶은 파일의 결과 값을 설정하는 것이 output이다.
        var path = require('path'); // node에서 제공하는 api
        module.exports = {
                 entry : {
                        //....
                  },
                  output: {
                    path: path.resolve(__dirname,'dist'),
                    filename: 'bundle.js'
                  }
        }

* output Name Option
        -> 1. [name] : 엔트리 명에 따른 output 파일명 생성
        -> 2. [hash] : 특정 webpack build에 따른 output 파일명 생성
        -> 3. [chunkhash] : 특정 webpack chunk에 따른 output 파일명 생성
        output:{
                filename: '[name].js',
                filename: '[hash].js',
                filename: '[chunkhash].js'
        }

* path.join()
        -> 해당 API가 동작되는 OS의 파일 구분자를 이용하여 파일 위치를 조합하는 방법
        path.join('/foo','bar'); => /foo/bar

* path.resolve()
        -> join 의 경우 단순히 문자열을 합치는 기능이지만, resolve의 경우 오른쪽에서 왼쪽으로 파일 위치를 구성해가며 유효한 위치를 찾는다.
        -> 만약에 결과 값이 유효하지 않다면 현재 디렉토리가 사용된다. 반환되는 위치 값은 항상 absolute URL이다.
        path.resolve('/foo/bar','./baz'); => /foo/bar/baz
        path.resolve('/foo/bar','/tmp/file'); => /tmp/file
        path.resolve('wwwroot','/file/image','../gif/a.gif'); => 최근 사용한 디렉토리가 home/self/test 라면 /home/self/test/wwwroot/file/image/gif/a.gif 로 구성된다.

* webpack Loader
        -> 웹팩은 자바스크립트 파일만 처리가 가능하다.
        -> loader를 이용하면 다른 형태의 웹 자원들도 js로 변환하여 로딩을 할 수 있다.
        module.exports = {
                 entry : {
                    //....
                  },
                  output: {
                    //..
                  }
        }

* Babel Loader - ES6
        - preset : Babel 플러그인 리스트
        module:{
                rules : [{
                        test:/\.js$./,
                        use :[{
                                loader : 'babel-loader',
                                options:{
                                        presets : [
                                                ['es2015', 'react', {modules:false}] // Tree Shaking : 모듈에서 사용되지 않는 것은 제외한다.
                                        ]
                                }
                        }]
                }]
        }

* Tapable.plugin is deprecated. Use new API on `.hooks` instead 오류 대처 방법
        - 인터넷 검색으로는 extract-text-webpack-plugin 을 설치하면 해당 현상이 안난다는 글 들이 많았다.
        - 해당 방법으로 설정을 했지만, 같은 오류 발생으로 추가적인 검색을 한 결과 4.0.0 의 alpha 버전으로 하면 가능하다는 글이 있어 시도했다.
                - "extract-text-webpack-plugin": "^4.0.0-beta.0" 에서 "extract-text-webpack-plugin": "^4.0.0-alpha.0" 로 변경
        - alpha 버전으로 변경 후 webpack을 돌렸더니 정상적인 built가 완료 되었다.

* Webpack Plugins
        - 플러그인은 파일별 커스텀 기능을 사용하기 위해서 사용한다.
                ex ) JS minification, File extraction, alias
        module.exports = {
                entry : {},
                output : {},
                module : {},
                plugins : [
                        new webpack.optimize.UglifyJsPlugin()
                ]
        }

* Plugin 추천
        - providePlugins : 모든 모듈에서 사용할 수 있도록 해당 모듈을 변수로 변환한다.
                new webpack.ProvidePlugin({
                        $: "jquery"
                })

        - definePlugin : 웹팩 번들링을 시작하는 시점에 사용 가능한 상수들을 정의한다.
                         일반 적으로 개발계 & 테스트계에 따라 다른 설정을 적용 할 때 유용하다.
                 new webpack.DefinePlugin({
                         PRODUCTION : JSON.stringify(true),
                         VERSION : JSON.stringify("5fa3b9"),
                         BROWSER_SUPPROTS_HTML : true,
                         TWO : "1+1",
                         "typeof window" : JSON.stringify("object")
                 })

         - ManifestPlugin : 번들링시 생성되는 코드(라이브러리)에 대한 정보를 json파일로 저장하여 관리
                 new webpack.ManifestPlugin({
                         fileName : "manifest.json",
                         basePath : "./dist"
                 })

 * 오류사항
        - 아래와 같은 코드 사용시 webpack 오류가 생겨 확인해보니 CommonsChunkPlugin의 경우 webpack4로 오면서 사라졌다고 한다.
                plugins: [
                        new webpack.optimize.CommonsChunkPlugin({
                                name: 'vendor' // Specify the common bundle's name.
                        }),
                ]
        - 변경하여 처리한 소스는 아래와 같다.
                plugins: [
                        new webpack.optimize.SplitChunksPlugin({
                                optimization: {
                                        splitChunks: {
                                                cacheGroups: {
                                                        vendor: {
                                                                chunks: 'initial',
                                                                name: 'vendor',
                                                                enforce: true,
                                                        },
                                                },
                                        },
                                        runtimeChunk: {
                                                name: 'manifest',
                                        }
                                },
                        })
                ]

        * Webpack Resolve
                - Webpack의 모듈 번들링 관점에서 봤을 때, 모듈 간의 의존성을 고려하여 로딩해야 한다.
                - 따라서 모듈을 어떤 위치에서 어떻게 로딩할지에 대해 정의를 하는 것이 Module Resolution이다.
                        // 일반적
                        import foo from 'path/to/module'
                        // 혹은
                        require('path/to/module')

                - 1. 절대 경로를 이용한 파일 로딩
                        - 파일의 경로를 모두 입력해준다.
                                import '/home/me/file';
                                import 'c:\\Users\\me\\file';

                - 2. 상대 경로를 이용한 파일 로딩
                        - 해당 모듈이 로딩되는 시점의 위치에 기반하여 절대 경로로 인식하여 로딩한다.
                                import '../src/file1';
                                import './file2';

        *Resolve Option
                - config 파일에 resolve를 추가하여 모듈 로딩에 관련된 옵션 사용
                - alias : 특정 모듈을 로딩할 때 alias  옵션을 이용하면 별칭으로 로딩이 가능
                        - alias : {
                                Utilities : path.resolve(__dirname, 'src/path/utilities')
                        }
                        - import Utility from '../../src/path/utilities/utility';
                        - import Utility from 'Utilities/utility'; // alias 사용시 더 간편하게 사용 가능
                - modules : require() import '' 과 같은 모듈 로딩시에 어느 폴더를 기준으로 할 것인지 정하는 옵션
                        - modules : ['node_modules'] // default
                        - modules : [path.resolve(__dirname, 'src'), 'node_modules'] // src/node_modules
                        
